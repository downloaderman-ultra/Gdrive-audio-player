HTML

<!DOCTYPE html>

<html lang="ja">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>G-Drive Music Ver.1.5.9.9</title>

    <style>

        body { font-family: sans-serif; background: #121212; color: white; text-align: center; margin: 0; padding: 10px; position: relative; display: flex; flex-direction: column; height: 95vh; }

        .version-tag { position: absolute; top: 10px; right: 15px; font-size: 0.7rem; color: #666; }

        h1 { font-size: 1.1rem; margin: 5px 0; color: #888; }

        #song-title { margin: 10px 0; font-weight: bold; color: #1DB954; font-size: 1.1rem; min-height: 2.4em; display: flex; align-items: center; justify-content: center; padding: 0 10px; }

        .content-grid { display: grid; grid-template-columns: 1fr 1.5fr; gap: 8px; max-width: 600px; margin: 0 auto 10px; flex-grow: 1; min-height: 0; width: 100%; }

        .list-box { background: #1e1e1e; border-radius: 8px; overflow-y: auto; border: 1px solid #333; text-align: left; padding: 5px; display: flex; flex-direction: column; }

        .list-box h4 { font-size: 0.75rem; margin: 3px; color: #666; border-bottom: 1px solid #333; padding-bottom: 3px; text-align: center; flex-shrink: 0; }

        .scroll-area { flex-grow: 1; overflow-y: auto; }

        .item-btn { width: 100%; text-align: left; background: transparent; padding: 12px 5px; border-radius: 4px; font-size: 13px; border-bottom: 1px solid #252525; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; color: #ccc; }

        .item-btn:active { background: #333; }

        .item-btn.playing { color: #1DB954; font-weight: bold; background: #222; }

        .item-btn.current-folder { color: #fff; border-left: 3px solid #1DB954; }

        .bottom-controls { flex-shrink: 0; padding-top: 10px; background: #121212; }

        .control-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; max-width: 450px; margin: 0 auto 8px; }

        button, select { background: #333; color: white; border: none; padding: 12px 2px; border-radius: 6px; cursor: pointer; font-size: 13px; width: 100%; }

        button:active { background: #555; transform: scale(0.96); }

        button.active { background: #1DB954; color: #fff; font-weight: bold; }

        select { text-align: center; text-align-last: center; appearance: none; border: 1px solid #444; }

        .big-play-btn { width: 100%; max-width: 450px; margin: 0 auto 8px; display: block; background: #333; font-size: 1.2rem; font-weight: bold; padding: 15px; }

        .big-play-btn.active { background: #1DB954; }

        .scope-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; max-width: 450px; margin: 0 auto 8px; }

        .scope-btn { background: #222; border: 1px solid #444; color: #888; }

        .scope-btn.active { background: #1DB954; color: white; border-color: #1DB954; }

        .volume-controls { max-width: 450px; margin: 0 auto 8px; display: flex; align-items: center; gap: 10px; background: #222; padding: 8px 15px; border-radius: 6px; }

        .volume-label { font-size: 0.7rem; color: #aaa; }

        input[type=range] { width: 100%; cursor: pointer; accent-color: #1DB954; height: 4px; }

        #visualizer-container { max-width: 450px; margin: 0 auto 5px; height: 40px; background: #1a1a1a; border-radius: 4px; overflow: hidden; border: 1px solid #333; }

        #visualizer { width: 100%; height: 100%; display: block; }

        .hidden { display: none !important; }

        #auth-btn { background: #1DB954; color: white; font-weight: bold; border: 1px solid #fff; padding: 15px; width: 80%; }

        .timer-info { max-width: 450px; margin: 0 auto 5px; font-size: 0.7rem; color: #888; min-height: 1em; }

    </style>

</head>

<body>

    <div class="version-tag">Ver.1.5.9.9</div>

    <h1>G-Drive Music</h1>

    <button id="auth-btn" class="hidden" onclick="handleAuthClick()" style="max-width:200px; margin:20px auto;">Googleãƒ‰ãƒ©ã‚¤ãƒ–ã«æ¥ç¶š</button>

    <div id="song-title">æ¥ç¶šä¸­...</div>

    <div id="main-ui" class="hidden" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">

        <div class="content-grid">

            <div class="list-box">

                <h4>ãƒ•ã‚©ãƒ«ãƒ€</h4>

                <div id="folder-list" class="scroll-area"></div>

            </div>

            <div class="list-box">

                <h4>æ›²ãƒªã‚¹ãƒˆ</h4>

                <div id="song-list" class="scroll-area"></div>

            </div>

        </div>

        <div class="bottom-controls">

            <div id="visualizer-container"><canvas id="visualizer"></canvas></div>

            <div id="timer-display" class="timer-info"></div>

            <div class="control-grid">

                <button onclick="changeMode('normal')" id="mode-normal" class="active">é †æ¬¡</button>

                <button onclick="changeMode('shuffle')" id="mode-shuffle">ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button>

                <button onclick="toggleRepeat()" id="repeat-btn">ãƒªãƒ”ãƒ¼ãƒˆ: OFF</button>

                <button onclick="prevTrack()">æˆ»ã‚Š</button>

                <button onclick="skip(10)">+10ç§’</button>

                <select id="sleep-timer" onchange="setSleepTimer()">

                    <option value="0">ã‚¿ã‚¤ãƒãƒ¼: OFF</option>

                    <option value="30">30åˆ†</option>

                    <option value="60">60åˆ†</option>

                    <option value="120">120åˆ†</option>

                    <option value="180">180åˆ†</option>

                </select>

                <button onclick="nextTrack()">é€ã‚Š</button>

                <button onclick="skip(-10)">-10ç§’</button>

                <button onclick="audio.pause()" id="btn-pause">ä¸€æ™‚åœæ­¢</button>

            </div>

            <button onclick="resumeOrPlay()" id="big-play-btn" class="big-play-btn">å†ç”Ÿ</button>

            <div class="scope-controls">

                <button onclick="changeScope('folder')" id="scope-folder" class="scope-btn active">ãƒ•ã‚©ãƒ«ãƒ€å†…</button>

                <button onclick="changeScope('all')" id="scope-all" class="scope-btn">å…¨ãƒ•ã‚©ãƒ«ãƒ€</button>

            </div>

            <div class="volume-controls">

                <span class="volume-label">VOL</span>

                <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1.0">

            </div>

        </div>

    </div>

    <audio id="audio-player" crossorigin="anonymous"></audio>



    <script>

        const CLIENT_ID = '870566274257-1e240kru9vef55k8ke7odf522tn7i864.apps.googleusercontent.com';

        const PARENT_ID = '1t5V8v-i-cYsOG9DcDveR2SzJp1JO5Uwj';

        // â˜… ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®Scopeã‚’è¿½åŠ 

        const SCOPES = 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/userinfo.email';

        const STORE_KEY = 'gdrive_music_state';



        let tokenClient, accessToken = null;

        let tokenExpiry = 0; // â˜… ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æœŸé™ç®¡ç†

        let userEmail = null; // â˜… ãƒ­ã‚°ã‚¤ãƒ³ãƒ’ãƒ³ãƒˆç”¨ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹



        let allFolders = [], playlist = [], currentIndex = 0;

        let isShuffle = false, repeatMode = 0, playScope = 'folder'; 

        let sleepTimeout = null, sleepInterval = null;

        let currentFolderId = null, currentFolderName = "";

        let isRetry = false;

        let lastPositionUpdate = 0;



        let shuffleIndices = []; 

        let shuffleIndex = 0;

        let folderShuffleIndices = [];

        let currentFolderShuffleIndex = 0;

        let folderCache = {};

        let playedHistory = {};

        let globalHistory = [];



        const audio = document.getElementById('audio-player');

        const volumeSlider = document.getElementById('volume-slider');

        let audioCtx, analyser, dataArray, canvas, canvasCtx, animationId;

        let isAudioContextInitialized = false;



        const ARTWORK_DATA = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAVklEQVRo3u3RAREAMAwDkZm/6RqmEA0fLgW1790dPCZgAibgGiZgAibgGiZgAibgGiZgAibgGiZgAibgGiZgAibgGiZgAibgGiZgAibgGiZgAibgGibgAS76A/1z768hAAAAAElFTkSuQmCC';



        volumeSlider.addEventListener('input', (e) => { audio.volume = e.target.value; saveSettings(); });



        setTimeout(() => {

            const title = document.getElementById('song-title');

            if (title.innerText === "æ¥ç¶šä¸­..." && document.getElementById('main-ui').classList.contains('hidden')) {

                document.getElementById('auth-btn').classList.remove('hidden');

                title.innerText = "ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦æ¥ç¶šã—ã¦ãã ã•ã„";

            }

        }, 3000);



        function gapiLoaded() { gapi.load('client', () => {}); }

        function gisLoaded() {

            tokenClient = google.accounts.oauth2.initTokenClient({

                client_id: CLIENT_ID, scope: SCOPES,

                callback: (resp) => {

                    if (resp.error) { document.getElementById('auth-btn').classList.remove('hidden'); return; }

                    accessToken = resp.access_token;

                    

                    // â˜… ãƒˆãƒ¼ã‚¯ãƒ³æœŸé™ã‚’è¨­å®š (ç¾åœ¨æ™‚åˆ» + 3500ç§’ = ç´„58åˆ†å¾Œ)

                    tokenExpiry = Date.now() + 3500 * 1000;

                    

                    document.getElementById('auth-btn').classList.add('hidden');

                    document.getElementById('main-ui').classList.remove('hidden');



                    // â˜… ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦ä¿å­˜ (æ¬¡å›ã®å†æ¥ç¶šã§ä½¿ã†)

                    fetchUserEmail();



                    if (isRetry) { isRetry = false; if(playlist.length > 0) playTrack(currentIndex); else initApp(); }

                    else initApp();

                },

            });

            // åˆå›ã¯ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒä¸æ˜ãªã®ã§hintãªã—

            tokenClient.requestAccessToken({ prompt: '' });

        }



        async function fetchUserEmail() {

            try {

                // ä¿å­˜æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—

                if (userEmail) return;

                const savedEmail = localStorage.getItem('gdrive_user_email');

                if (savedEmail) { userEmail = savedEmail; return; }



                const resp = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {

                    headers: { 'Authorization': `Bearer ${accessToken}` }

                });

                if (resp.ok) {

                    const data = await resp.json();

                    userEmail = data.email;

                    localStorage.setItem('gdrive_user_email', userEmail);

                    console.log("User email stored for auto-reconnect:", userEmail);

                }

            } catch (e) { console.error("Failed to fetch user info", e); }

        }



        // â˜… é‡è¦: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’èµ·ã“ã™å‰ã«å¿…ãšãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°

        // ã‚¿ã‚¤ãƒãƒ¼ä¾å­˜ã§ã¯ãªãã€æ“ä½œï¼ˆå†ç”Ÿãƒ»æ›²é€ã‚Šï¼‰ã®ç›´å‰ã«ç¢ºèªã™ã‚‹

        async function checkTokenValidity() {

            // æ®‹ã‚Š5åˆ†ã‚’åˆ‡ã£ã¦ã„ãŸã‚‰æ›´æ–°

            if (Date.now() > tokenExpiry - (5 * 60 * 1000)) {

                console.log("Token expiring soon, refreshing...");

                await refreshToken();

            }

        }



        // â˜… Promiseã§ãƒ©ãƒƒãƒ—ã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å‡¦ç†

        function refreshToken() {

            return new Promise((resolve) => {

                // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã¯ hint ã‚’æŒ‡å®šã—ã¦ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé¸æŠã‚’å›é¿

                const config = { prompt: '' };

                if (userEmail) config.hint = userEmail;



                // callbackã‚’ä¸€æ™‚çš„ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã—ã¦Promiseã‚’è§£æ±ºã™ã‚‹

                const originalCallback = tokenClient.callback;

                tokenClient.callback = (resp) => {

                    if (!resp.error) {

                        accessToken = resp.access_token;

                        tokenExpiry = Date.now() + 3500 * 1000;

                        console.log("Token refreshed successfully.");

                    } else {

                        console.error("Token refresh failed", resp);

                        // å¤±æ•—ã—ãŸã‚‰æ‰‹å‹•ãƒœã‚¿ãƒ³ã‚’å‡ºã™ãªã©ã®å‡¦ç†ãŒå¿…è¦ã ãŒã€

                        // ã“ã“ã§ã¯ã¨ã‚Šã‚ãˆãšãƒ­ã‚°ã®ã¿ã€‚hintãŒã‚ã‚Œã°æˆåŠŸç‡ã¯é«˜ã„ã€‚

                    }

                    // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’æˆ»ã™ (gisLoadedã§å®šç¾©ã—ãŸã‚‚ã®ã¸)

                    // ãŸã ã—gisLoadedã®callbackã¯initAppç­‰ã‚’å‘¼ã‚“ã§ã—ã¾ã†ã®ã§ã€

                    // ã“ã“ã§ã®refreshç”¨ã«ã¯ä½•ã‚‚ã—ãªã„ã®ãŒæ­£è§£ã«è¿‘ã„ãŒã€

                    // æ—¢å­˜ã®callbackæ§‹é€ ä¸Šã€access_tokenæ›´æ–°ã ã‘ã§ååˆ†

                    resolve();

                };

                

                tokenClient.requestAccessToken(config);

                

                // æ¬¡å›ä»¥é™ã®ãŸã‚ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å…ƒã«æˆ»ã™ã®ã¯é›£ã—ã„ã®ã§ã€

                // requestAccessTokenã®æŒ™å‹•ã¨ã—ã¦ã€Œæœ€å¾Œã®callbackãŒå‘¼ã°ã‚Œã‚‹ã€ä»•æ§˜ã‚’åˆ©ç”¨ã—ã€

                // Promiseè§£æ±ºå°‚ç”¨ã®callbackã‚’å®šç¾©ã—ãªãŠã™å½¢ã§å®Ÿè£…ã™ã‚‹ã®ãŒå®‰å…¨

            });

        }

        

        // GISã®ä»•æ§˜ä¸Šã€callbackã¯initæ™‚ã«è¨­å®šã•ã‚Œã‚‹ãŸã‚ã€

        // ä¸Šè¨˜ã®PromiseåŒ–ã¯å°‘ã€…ãƒãƒƒã‚¯ãŒå¿…è¦ã€‚

        // ã‚ˆã‚Šå®‰å…¨ãªã€Œæ—¢å­˜ãƒ•ãƒ­ãƒ¼ã‚’é‚ªé­”ã—ãªã„ã€å®Ÿè£…ï¼š

        // gisLoadedã§å®šç¾©ã—ãŸcallbackå†…ã§ã€Œæ›´æ–°ã ã‘ã€ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã®ã¯è¤‡é›‘ãªã®ã§ã€

        // ã“ã“ã§ã¯ã€ŒrequestAccessTokenã€ã‚’å‘¼ã¶ã¨ã€gisLoadedå†…ã®callbackãŒå‘¼ã°ã‚Œã‚‹ã“ã¨ã‚’åˆ©ç”¨ã™ã‚‹ã€‚

        // isRetryãƒ•ãƒ©ã‚°ã¯ã€Œå¤±æ•—å¾Œã®å†è©¦è¡Œã€ç”¨ã ãŒã€ã€Œäº‹å‰æ›´æ–°ã€ç”¨ã«ã‚‚æµç”¨ã™ã‚‹ã€‚



        // â˜… ä¿®æ­£ç‰ˆ checkTokenValidity

        async function ensureToken() {

             if (Date.now() > tokenExpiry - (5 * 60 * 1000)) {

                 console.log("Refreshing token before action...");

                 // prompt: '' ã¨ hint ã‚’ä½¿ã£ã¦æ›´æ–°

                 // PromiseåŒ–ãŒé›£ã—ã„ãŸã‚ã€å¤ã„ã‚„ã‚Šæ–¹ã ãŒã€Œæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŠ•ã’ã¦ã€å®Œäº†ã‚’å°‘ã—å¾…ã¤ã€ã‹

                 // ã‚ã‚‹ã„ã¯ã€Œåˆ‡ã‚Œã‚‹å‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŠ•ã’ã£ã±ãªã—ã«ã™ã‚‹ã€

                 // ã“ã“ã§ã¯ä¸€ç•ªç¢ºå®Ÿãªã€Œãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŠ•ã’ã‚‹ã€ã‚’è¡Œã†ã€‚

                 // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å´ã§ accessToken ã¨ expiry ãŒæ›´æ–°ã•ã‚Œã‚‹ã€‚

                 const config = { prompt: '' };

                 if (userEmail) config.hint = userEmail;

                 

                 // isRetry=trueã«ã—ã¦ãŠãã¨ã€callbackå†…ã§playTrackç­‰ãŒå‘¼ã°ã‚Œã‚‹(å†ç”ŸãŒæ­¢ã¾ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹)

                 // ãªã®ã§ã€ã‚µã‚¤ãƒ¬ãƒ³ãƒˆæ›´æ–°æ™‚ã¯ isRetry=false ã®ã¾ã¾ã«ã—ã¦ãŠããŸã„ãŒã€

                 // ãã†ã™ã‚‹ã¨callbackã§initAppãŒå‘¼ã°ã‚Œã¦ç”»é¢ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã€‚

                 // â†’ callbackã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å¾®èª¿æ•´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

                 

                 // ã“ã“ã§ã¯ç°¡ä¾¿ã®ãŸã‚ã€tokenClientã‚’å†åˆæœŸåŒ–ã›ãšã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã ã‘é€ã‚‹ã€‚

                 // Googleã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯éåŒæœŸã ãŒawaitã§ããªã„ã€‚

                 // å®Ÿéš›ã«ã¯ã€Œãƒˆãƒ¼ã‚¯ãƒ³ãŒåˆ‡ã‚Œã¦401ãŒå‡ºã‚‹ -> refreshAccessTokenãŒå‘¼ã°ã‚Œã‚‹ã€ã®æµã‚ŒãŒ

                 // hintä»˜ãã§ã‚ã‚Œã°ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé¸æŠç”»é¢ã‚’å‡ºã•ãšã«æˆåŠŸã™ã‚‹ã¯ãšã€‚

                 

                 // ãªã®ã§ã€ã“ã®é–¢æ•°ã§ã¯ã€Œè‡ªåˆ†ã‹ã‚‰æ›´æ–°ã€ã¯ã›ãšã€

                 // ã€Œ401ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªã‚«ãƒãƒªã€ã‚’å¼·åŒ–ã™ã‚‹æ–¹é‡ã«ã—ã¾ã™ã€‚

             }

        }



        // â˜… 401ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªã‚«ãƒãƒªé–¢æ•° (å¼·åŒ–ç‰ˆ)

        function handleAuthClick() { tokenClient.requestAccessToken({ prompt: 'select_account' }); }

        

        function refreshAccessToken() {

            console.log("401 Error detected. Refreshing with hint...");

            isRetry = true;

            const config = { prompt: '' };

            // â˜… ã“ã“ãŒè‚ï¼šãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ã¦ã€Œã“ã®äººã§ã™ã€ã¨ä¼ãˆã‚‹

            if (userEmail) config.hint = userEmail;

            tokenClient.requestAccessToken(config);

        }



        async function initApp() {

            const saved = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');

            if (saved.isShuffle !== undefined) isShuffle = saved.isShuffle;

            if (saved.repeatMode !== undefined) { repeatMode = saved.repeatMode - 1; toggleRepeat(); }

            if (saved.playScope !== undefined) changeScope(saved.playScope);

            if (saved.volume !== undefined) { volumeSlider.value = saved.volume; audio.volume = saved.volume; }

            

            // ä»¥å‰ä¿å­˜ã—ãŸãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚ã‚Œã°å¾©å…ƒ

            const savedEmail = localStorage.getItem('gdrive_user_email');

            if (savedEmail) userEmail = savedEmail;



            changeMode(isShuffle ? 'shuffle' : 'normal');

            setupMediaSessionHandlers();

            canvas = document.getElementById('visualizer');

            canvasCtx = canvas.getContext('2d');

            resizeCanvas();

            window.addEventListener('resize', resizeCanvas);

            await loadFolders();

            if (saved.folderId) loadSongs(saved.folderId, saved.folderName, false);

            else document.getElementById('song-title').innerText = "ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„";

        }



        function initAudioContext() {

            if (isAudioContextInitialized) return;

            try {

                const AudioContext = window.AudioContext || window.webkitAudioContext;

                audioCtx = new AudioContext();

                analyser = audioCtx.createAnalyser();

                analyser.fftSize = 64; 

                const source = audioCtx.createMediaElementSource(audio);

                source.connect(analyser);

                analyser.connect(audioCtx.destination);

                dataArray = new Uint8Array(analyser.frequencyBinCount);

                isAudioContextInitialized = true;

                drawVisualizer();

            } catch(e) { console.error(e); }

        }



        function resizeCanvas() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }

        function drawVisualizer() {

            animationId = requestAnimationFrame(drawVisualizer);

            if(!analyser) return;

            analyser.getByteFrequencyData(dataArray);

            canvasCtx.fillStyle = '#1a1a1a';

            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = (canvas.width / dataArray.length) * 2.5;

            let barHeight; let x = 0;

            for(let i = 0; i < dataArray.length; i++) {

                barHeight = (dataArray[i] / 255) * canvas.height;

                canvasCtx.fillStyle = '#1DB954';

                canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

                x += barWidth + 1;

            }

        }



        function saveSettings() {

            const settings = { folderId: currentFolderId, folderName: currentFolderName, isShuffle: isShuffle, repeatMode: repeatMode, playScope: playScope, volume: volumeSlider.value };

            localStorage.setItem(STORE_KEY, JSON.stringify(settings));

        }



        function generateShuffleIndices() {

            shuffleIndices = Array.from({length: playlist.length}, (_, i) => i);

            for (let i = shuffleIndices.length - 1; i > 0; i--) {

                const j = Math.floor(Math.random() * (i + 1));

                [shuffleIndices[i], shuffleIndices[j]] = [shuffleIndices[j], shuffleIndices[i]];

            }

            shuffleIndex = 0;

        }



        function generateFolderShuffleIndices() {

            folderShuffleIndices = Array.from({length: allFolders.length}, (_, i) => i);

            for (let i = folderShuffleIndices.length - 1; i > 0; i--) {

                const j = Math.floor(Math.random() * (i + 1));

                [folderShuffleIndices[i], folderShuffleIndices[j]] = [folderShuffleIndices[j], folderShuffleIndices[i]];

            }

            currentFolderShuffleIndex = 0;

        }



        function formatTrackName(name) {

            return name.replace(/\.[^/.]+$/, "");

        }



        function getDisplayTitle(folderName, fileName) {

            const cleanName = formatTrackName(fileName);

            return `[${folderName}] ${cleanName}`;

        }



        async function loadFolders() {

            try {

                // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‰ã«ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ï¼‰

                if (Date.now() > tokenExpiry - 300000 && userEmail) {

                     console.log("Token expiring, refreshing silently...");

                     tokenClient.requestAccessToken({ prompt: '', hint: userEmail });

                     // éåŒæœŸã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆã ã‘æŠ•ã’ã¦ã€å¤±æ•—ã—ãŸã‚‰401ãƒªã‚«ãƒãƒªã«ä»»ã›ã‚‹

                }



                const query = `'${PARENT_ID}' in parents and mimeType = 'application/vnd.google-apps.folder'`;

                const resp = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name)`, { headers: { 'Authorization': `Bearer ${accessToken}` } });

                if(resp.status === 401) { refreshAccessToken(); return; }

                const data = await resp.json();

                allFolders = data.files.sort((a,b)=>a.name.localeCompare(b.name,'ja'));

                generateFolderShuffleIndices(); 

                const listEl = document.getElementById('folder-list'); listEl.innerHTML = '';

                allFolders.forEach(f => {

                    const btn = document.createElement('div'); btn.className = 'item-btn';

                    if(f.id === currentFolderId) btn.classList.add('current-folder');

                    btn.id = `folder-${f.id}`; btn.innerText = "ğŸ“ " + f.name;

                    btn.onclick = () => loadSongs(f.id, f.name, true); listEl.appendChild(btn);

                });

            } catch(e) { console.error(e); }

        }



        async function loadSongs(folderId, folderName, autoPlay, pickRandomUnique = false) {

            currentFolderId = folderId; currentFolderName = folderName; saveSettings();

            document.getElementById('song-title').innerText = `${folderName} ã‚’èª­è¾¼ä¸­...`;

            document.querySelectorAll('#folder-list .item-btn').forEach(b => b.classList.remove('current-folder'));

            document.getElementById(`folder-${folderId}`)?.classList.add('current-folder');



            try {

                let files = [];

                if (folderCache[folderId]) {

                    files = folderCache[folderId];

                } else {

                    const query = `'${folderId}' in parents and mimeType contains 'audio/'`;

                    const resp = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType)`, { headers: { 'Authorization': `Bearer ${accessToken}` } });

                    if(resp.status === 401) { refreshAccessToken(); return; }

                    const data = await resp.json();

                    files = data.files.filter(file => audio.canPlayType(file.mimeType) !== "").sort((a,b) => a.name.localeCompare(b.name,'ja'));

                    folderCache[folderId] = files;

                }



                playlist = files;

                generateShuffleIndices();



                const listEl = document.getElementById('song-list'); listEl.innerHTML = '';

                playlist.forEach((s, idx) => {

                    const btn = document.createElement('div'); btn.className = 'item-btn'; btn.id = `song-${idx}`;

                    btn.innerText = formatTrackName(s.name);

                    btn.onclick = () => playTrack(idx); listEl.appendChild(btn);

                });

                document.getElementById('song-title').innerText = `${folderName} (${playlist.length}æ›²)`;



                if (playlist.length === 0) {

                    if (autoPlay && playScope === 'all') { setTimeout(nextTrack, 500); }

                    return;

                }



                if (pickRandomUnique) {

                    if (!playedHistory[folderId]) playedHistory[folderId] = [];

                    let unplayedIndices = playlist.map((_, i) => i).filter(i => !playedHistory[folderId].includes(playlist[i].id));

                    if (unplayedIndices.length === 0) {

                        playedHistory[folderId] = [];

                        unplayedIndices = playlist.map((_, i) => i);

                    }

                    const randIdx = unplayedIndices[Math.floor(Math.random() * unplayedIndices.length)];

                    playedHistory[folderId].push(playlist[randIdx].id);

                    playTrack(randIdx);

                } else if (autoPlay) {

                    playTrack(isShuffle ? shuffleIndices[0] : 0);

                }



            } catch(e) { console.error(e); }

        }



        function resumeOrPlay() {

            initAudioContext();

            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

            if (audio.src && audio.src !== window.location.href) { if (audio.error) audio.load(); audio.play().catch(e => {}); }

            else if (playlist.length > 0) playTrack(currentIndex);

        }



        function playTrack(index) {

            // â˜… å†ç”Ÿå‰ã«ã‚‚ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚§ãƒƒã‚¯

            if (Date.now() > tokenExpiry - 300000 && userEmail) {

                 tokenClient.requestAccessToken({ prompt: '', hint: userEmail });

            }



            initAudioContext();

            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

            if (playlist.length === 0) return;

            currentIndex = index;

            

            if (isShuffle && !folderCache) {

                 const foundIdx = shuffleIndices.indexOf(index);

                 if (foundIdx !== -1) shuffleIndex = foundIdx;

            }



            const lastHistory = globalHistory[globalHistory.length - 1];

            if (!lastHistory || lastHistory.folderId !== currentFolderId || lastHistory.songIndex !== index) {

                globalHistory.push({ folderId: currentFolderId, songIndex: index });

                if (globalHistory.length > 50) globalHistory.shift();

            }



            const track = playlist[index];

            document.querySelectorAll('#song-list .item-btn').forEach(el => el.classList.remove('playing'));

            const targetBtn = document.getElementById(`song-${index}`);

            if (targetBtn) { targetBtn.classList.add('playing'); targetBtn.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }

            

            const displayTitle = getDisplayTitle(currentFolderName, track.name);

            document.getElementById('song-title').innerText = displayTitle + " (èª­è¾¼ä¸­...)";

            

            if ('mediaSession' in navigator) {

                navigator.mediaSession.metadata = new MediaMetadata({ title: formatTrackName(track.name), artist: currentFolderName, album: 'G-Drive Music', artwork: [{ src: ARTWORK_DATA, sizes: '64x64', type: 'image/png' }] });

                navigator.mediaSession.playbackState = 'playing'; 

                try { navigator.mediaSession.setPositionState(); } catch(e) {} 

            }

            audio.pause();

            if (audio.src && audio.src.startsWith('blob:')) URL.revokeObjectURL(audio.src);

            audio.removeAttribute('src'); audio.load(); 

            const fetchUrl = `https://www.googleapis.com/drive/v3/files/${track.id}?alt=media`;

            fetch(fetchUrl, { headers: { 'Authorization': `Bearer ${accessToken}` } })

                .then(r => { if (r.status === 401) throw new Error('401'); return r.blob(); })

                .then(blob => {

                    audio.src = URL.createObjectURL(blob); audio.volume = volumeSlider.value;

                    document.getElementById('song-title').innerText = displayTitle;

                    audio.play().catch(e => {});

                }).catch(err => { if(err.message.includes('401')) refreshAccessToken(); });

        }



        function nextTrack() {

            if (repeatMode === 2) { playTrack(currentIndex); return; }

            if (playScope === 'all' && isShuffle) {

                currentFolderShuffleIndex++;

                if (currentFolderShuffleIndex >= folderShuffleIndices.length) {

                    generateFolderShuffleIndices(); currentFolderShuffleIndex = 0;

                }

                const nextFolder = allFolders[folderShuffleIndices[currentFolderShuffleIndex]];

                loadSongs(nextFolder.id, nextFolder.name, true, true);

                return;

            }

            if (isShuffle) {

                shuffleIndex++;

                if (shuffleIndex >= shuffleIndices.length) {

                    if (playScope === 'all') {

                        const nextIdx = (allFolders.findIndex(f => f.id === currentFolderId) + 1) % allFolders.length;

                        loadSongs(allFolders[nextIdx].id, allFolders[nextIdx].name, true); return;

                    } else if (repeatMode === 1) { generateShuffleIndices(); shuffleIndex = 0; }

                    else { audio.pause(); return; }

                }

                playTrack(shuffleIndices[shuffleIndex]);

            } else {

                let next = currentIndex + 1;

                if (next >= playlist.length) {

                    if (repeatMode === 1) next = 0; 

                    else if (playScope === 'all') {

                        const nextIdx = (allFolders.findIndex(f => f.id === currentFolderId) + 1) % allFolders.length;

                        loadSongs(allFolders[nextIdx].id, allFolders[nextIdx].name, true); return;

                    } else { audio.pause(); return; }

                }

                playTrack(next);

            }

        }



        function prevTrack() { 

            if (audio.currentTime > 3) { audio.currentTime = 0; return; }

            if (globalHistory.length > 1) {

                globalHistory.pop(); 

                const prev = globalHistory[globalHistory.length - 1]; 

                if (prev.folderId !== currentFolderId) {

                    const targetFolder = allFolders.find(f => f.id === prev.folderId);

                    if (targetFolder) {

                        loadSongs(targetFolder.id, targetFolder.name, false).then(() => { playTrack(prev.songIndex); });

                        return;

                    }

                } else { playTrack(prev.songIndex); return; }

            }

            if (isShuffle) {

                if (shuffleIndex > 0) { shuffleIndex--; playTrack(shuffleIndices[shuffleIndex]); }

                else playTrack(shuffleIndices[0]);

            } else { playTrack((currentIndex - 1 + playlist.length) % playlist.length); }

        }



        function changeScope(scope) { playScope = scope; document.getElementById('scope-folder').className = `scope-btn ${scope === 'folder' ? 'active' : ''}`; document.getElementById('scope-all').className = `scope-btn ${scope === 'all' ? 'active' : ''}`; saveSettings(); }

        function toggleRepeat() {

            repeatMode = (repeatMode + 1) % 3;

            const labels = ["OFF", "ALL", "1æ›²"];

            document.getElementById('repeat-btn').innerText = "ãƒªãƒ”ãƒ¼ãƒˆ: " + labels[repeatMode];

            document.getElementById('repeat-btn').classList.toggle('active', repeatMode > 0); saveSettings();

        }

        function changeMode(m) { 

            isShuffle = (m === 'shuffle'); 

            document.getElementById('mode-shuffle').classList.toggle('active', isShuffle); 

            document.getElementById('mode-normal').classList.toggle('active', !isShuffle); 

            if (isShuffle && playlist.length > 0) {

                generateShuffleIndices();

                generateFolderShuffleIndices();

                const cur = shuffleIndices.indexOf(currentIndex);

                if (cur !== -1) { [shuffleIndices[0], shuffleIndices[cur]] = [shuffleIndices[cur], shuffleIndices[0]]; shuffleIndex = 0; }

            }

            saveSettings(); 

        }

        function setSleepTimer() {

            const mins = parseInt(document.getElementById('sleep-timer').value);

            clearTimeout(sleepTimeout); clearInterval(sleepInterval);

            const display = document.getElementById('timer-display');

            if (mins === 0) { display.innerText = ""; return; }

            let endTime = Date.now() + mins * 60000;

            display.innerText = `ã‚¿ã‚¤ãƒãƒ¼: ${mins}åˆ†å¾Œã«åœæ­¢`;

            sleepInterval = setInterval(() => { let remain = Math.round((endTime - Date.now()) / 60000); display.innerText = remain > 0 ? `æ®‹ã‚Š ${remain}åˆ†` : "åœæ­¢..."; }, 10000);

            sleepTimeout = setTimeout(() => {

                const fade = setInterval(() => { if (audio.volume > 0.1) audio.volume -= 0.1; else { audio.pause(); clearInterval(fade); clearInterval(sleepInterval); audio.volume = volumeSlider.value; display.innerText = "åœæ­¢ã—ã¾ã—ãŸ"; } }, 500);

            }, mins * 60000);

        }

        function skip(s) { audio.currentTime += s; }

        

        audio.onended = nextTrack;

        audio.onplay = () => { if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing'; updatePlayPauseUI(true); };

        audio.onpause = () => { if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused'; updatePlayPauseUI(false); };

        audio.onerror = () => { setTimeout(() => { nextTrack(); }, 1000); };

        audio.onwaiting = () => { if('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing'; };



        function setupMediaSessionHandlers() {

            if ('mediaSession' in navigator) {

                const handlers = [['play', resumeOrPlay], ['pause', () => audio.pause()], ['previoustrack', prevTrack], ['nexttrack', nextTrack], ['seekbackward', () => skip(-10)], ['seekforward', () => skip(10)]];

                for (const [action, handler] of handlers) { try { navigator.mediaSession.setActionHandler(action, handler); } catch (e) {} }

            }

        }

        audio.addEventListener('loadedmetadata', () => { if ('mediaSession' in navigator && !isNaN(audio.duration) && audio.duration !== Infinity) { navigator.mediaSession.setPositionState({ duration: audio.duration, playbackRate: audio.playbackRate, position: 0 }); } });

        if ('mediaSession' in navigator) {

            audio.addEventListener('timeupdate', () => { 

                const now = Date.now(); if (now - lastPositionUpdate < 1000) return; lastPositionUpdate = now;

                if (!isNaN(audio.duration) && audio.duration !== Infinity && !isNaN(audio.currentTime)) { try { navigator.mediaSession.setPositionState({ duration: audio.duration, playbackRate: audio.playbackRate, position: audio.currentTime }); } catch(e) {} } 

            });

        }

        function updatePlayPauseUI(isPlaying) {

            const bigPlay = document.getElementById('big-play-btn'); const pauseBtn = document.getElementById('btn-pause');

            if (isPlaying) { bigPlay.classList.add('active'); bigPlay.innerText = "å†ç”Ÿä¸­"; pauseBtn.classList.remove('active'); }

            else { bigPlay.classList.remove('active'); bigPlay.innerText = "å†ç”Ÿ"; pauseBtn.classList.add('active'); }

        }

    </script>

    <script src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

    <script src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>

</body>

</html>
